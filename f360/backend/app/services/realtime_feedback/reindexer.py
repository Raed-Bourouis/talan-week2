"""
F360 – Récompense / Échec / Ré-indexation (Reindexer)
Feedback loop that:
- Scores prediction accuracy (reward/penalty)
- Triggers re-indexation of documents when gaps are detected
- Adjusts model parameters based on feedback
- Feeds back into the RAGraph episodic memory
"""
from __future__ import annotations

import logging
from datetime import datetime, timezone
from typing import Any

from sqlalchemy.ext.asyncio import AsyncSession

from app.services.realtime_feedback.gap_calculator import GapCalculator, GapResult
from app.services.cognitive_ingestion.indexer import reindex_document
from app.services.ragraph.episodic_memory import EpisodicMemory, Episode

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════
# FEEDBACK EVENT
# ═══════════════════════════════════════════════════════════════

class FeedbackEvent:
    """A feedback event generated by the gap analysis."""

    def __init__(
        self,
        gap: GapResult,
        action: str,
        reward: float,
        details: str = "",
    ):
        self.gap = gap
        self.action = action  # "reward", "penalize", "reindex", "alert"
        self.reward = reward   # -1.0 to 1.0
        self.details = details
        self.timestamp = datetime.now(timezone.utc)

    def to_dict(self) -> dict[str, Any]:
        return {
            "gap": self.gap.to_dict(),
            "action": self.action,
            "reward": self.reward,
            "details": self.details,
            "timestamp": self.timestamp.isoformat(),
        }


# ═══════════════════════════════════════════════════════════════
# FEEDBACK REINDEXER
# ═══════════════════════════════════════════════════════════════

class FeedbackReindexer:
    """
    Processes gap analysis results and triggers corrective actions:
    - Reward: accurate predictions → reinforce model confidence
    - Penalize: inaccurate predictions → trigger re-analysis
    - Reindex: document changes detected → re-vectorize
    - Alert: critical gaps → notify decision layer
    """

    def __init__(self):
        self.gap_calculator = GapCalculator()
        self.memory = EpisodicMemory()
        self._feedback_log: list[FeedbackEvent] = []

    async def process_feedback_cycle(
        self,
        company_id: str,
        fiscal_year: int,
        db: AsyncSession,
    ) -> dict[str, Any]:
        """
        Full feedback cycle:
        1. Compute all gaps (predicted vs actual)
        2. Classify each gap as reward/penalty
        3. Trigger re-indexation for critical gaps
        4. Store feedback in episodic memory
        5. Return summary for decision fusion
        """
        # ── 1. Compute gaps ──
        gaps_data = await self.gap_calculator.compute_all_gaps(company_id, fiscal_year, db)

        all_gaps: list[GapResult] = []
        for key in ["budget_gaps", "cashflow_gaps", "contract_gaps", "simulation_gaps"]:
            for gap_dict in gaps_data.get(key, []):
                gap = GapResult(
                    entity_type=gap_dict["entity_type"],
                    entity_id=gap_dict["entity_id"],
                    label=gap_dict["label"],
                    predicted=gap_dict["predicted"],
                    actual=gap_dict["actual"],
                    period=gap_dict.get("period"),
                )
                all_gaps.append(gap)

        # ── 2. Classify and generate feedback events ──
        feedback_events: list[FeedbackEvent] = []
        reindex_queue: list[str] = []

        for gap in all_gaps:
            event = self._classify_gap(gap)
            feedback_events.append(event)
            self._feedback_log.append(event)

            # ── 3. Queue re-indexation for critical gaps ──
            if event.action == "reindex" and gap.entity_id:
                reindex_queue.append(gap.entity_id)

        # ── 4. Store feedback in episodic memory ──
        for event in feedback_events:
            episode = Episode(
                query=f"Feedback: {event.gap.label}",
                answer=event.details,
                context_sources=[{"type": "feedback", "gap": event.gap.to_dict()}],
                feedback_score=max(0, event.reward),  # Normalize to 0-1
                company_id=company_id,
                tags=["feedback", event.action, event.gap.entity_type],
            )
            await self.memory.store(episode)

        # ── Summary ──
        summary = {
            "company_id": company_id,
            "fiscal_year": fiscal_year,
            "total_gaps_analyzed": len(all_gaps),
            "rewards": sum(1 for e in feedback_events if e.action == "reward"),
            "penalties": sum(1 for e in feedback_events if e.action == "penalize"),
            "reindex_triggered": len(reindex_queue),
            "alerts_raised": sum(1 for e in feedback_events if e.action == "alert"),
            "overall_accuracy": gaps_data.get("success_rate", 0),
            "feedback_events": [e.to_dict() for e in feedback_events],
            "reindex_queue": reindex_queue,
        }

        logger.info(
            f"Feedback cycle complete: {summary['rewards']} rewards, "
            f"{summary['penalties']} penalties, {summary['reindex_triggered']} reindexes"
        )

        return summary

    def _classify_gap(self, gap: GapResult) -> FeedbackEvent:
        """Classify a gap result into a feedback action."""
        pct = abs(gap.gap_pct)

        if gap.is_success:
            # Prediction was accurate → reward
            return FeedbackEvent(
                gap=gap,
                action="reward",
                reward=1.0 - (pct / 10),  # Higher reward for closer predictions
                details=f"Accurate prediction for {gap.label}: {gap.gap_pct:+.1f}% deviation",
            )

        elif pct < 20:
            # Moderate deviation → penalize lightly
            return FeedbackEvent(
                gap=gap,
                action="penalize",
                reward=-0.3,
                details=f"Moderate deviation for {gap.label}: {gap.gap_pct:+.1f}%",
            )

        elif pct < 35:
            # Significant deviation → trigger re-indexation
            return FeedbackEvent(
                gap=gap,
                action="reindex",
                reward=-0.7,
                details=(
                    f"Significant deviation for {gap.label}: {gap.gap_pct:+.1f}%. "
                    f"Re-indexation triggered to improve future predictions."
                ),
            )

        else:
            # Critical deviation → alert
            return FeedbackEvent(
                gap=gap,
                action="alert",
                reward=-1.0,
                details=(
                    f"CRITICAL deviation for {gap.label}: {gap.gap_pct:+.1f}%. "
                    f"Predicted: {gap.predicted:,.2f}, Actual: {gap.actual:,.2f}. "
                    f"Immediate review required."
                ),
            )

    async def trigger_reindexation(
        self,
        document_ids: list[str],
        db: AsyncSession,
    ) -> list[dict[str, Any]]:
        """
        Re-index documents that have shown significant prediction gaps.
        This improves future RAG retrieval accuracy.
        """
        import uuid
        results = []
        for doc_id_str in document_ids:
            try:
                doc_id = uuid.UUID(doc_id_str)
                result = await reindex_document(doc_id, db)
                results.append({
                    "document_id": doc_id_str,
                    "status": result.status,
                    "chunks_created": result.chunks_created,
                })
            except Exception as e:
                results.append({
                    "document_id": doc_id_str,
                    "status": "error",
                    "message": str(e),
                })
        return results

    def get_feedback_history(self, limit: int = 50) -> list[dict[str, Any]]:
        """Return recent feedback events."""
        return [e.to_dict() for e in self._feedback_log[-limit:]]
